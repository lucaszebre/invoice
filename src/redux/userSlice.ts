import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { auth, firestore } from '@/config/firebase';
import { Invoice , UserData } from '@/types/InvoiceType';
import { collection, doc, getDoc, getDocs } from 'firebase/firestore';

// Define the initial state
interface UserState {
    loadingUserData: boolean;
    userData: UserData | null;
    mod: boolean;
    invoices: Invoice[];
    invoiceId: string;
    invoice:Invoice|null
}

const initialState: UserState = {
    loadingUserData: true,
    userData: null,
    mod: false,
    invoices: [],
    invoiceId: '',
    invoice: null,
};

// Define async thunk for fetching an invoice
export const fetchInvoice = createAsyncThunk('user/fetchInvoice', async (invoiceId: string) => {
    if (!auth.currentUser || !invoiceId) return null;
    const userDocRef = doc(firestore, 'users', auth.currentUser.uid);
    const invoicesCollectionRef = collection(userDocRef, 'invoices');
    const invoiceDocRef = doc(invoicesCollectionRef, invoiceId);

    const invoiceDocSnapshot = await getDoc(invoiceDocRef);
    if (invoiceDocSnapshot.exists()) {
        const invoiceData = invoiceDocSnapshot.data() as Omit<Invoice, 'id'>;
        return { id: invoiceDocSnapshot.id, ...invoiceData };
    }
    return null;
});

// Define async thunk for fetching user data
export const fetchUserData = createAsyncThunk('user/fetchUserData', async (_, { rejectWithValue }) => {
try {
    if (!auth.currentUser) return rejectWithValue(null);
    const userDocRef = doc(firestore, 'users', auth.currentUser.uid);
    const invoicesCollectionRef = collection(userDocRef, 'invoices');

    const userDocSnapshot = await getDoc(userDocRef);
    let userData: UserData | null = null;
    if (userDocSnapshot.exists()) {
        const data = userDocSnapshot.data() as Omit<UserData, 'id'>;
        userData = { id: auth.currentUser.uid, ...data };
    }

    const invoicesQuerySnapshot = await getDocs(invoicesCollectionRef);
    const invoices: Invoice[] = [];
    invoicesQuerySnapshot.forEach((doc) => {
        const invoiceData = doc.data() as Omit<Invoice, 'id'>;
        invoices.push({ id: doc.id, ...invoiceData });
    });

    return { userData, invoices };
} catch (error) {
    if (error instanceof Error) {
        return rejectWithValue(error.message);
    }
        return rejectWithValue("An unknown error occurred");
}});

// Define the slice
const userSlice = createSlice({
    name: 'user',
    initialState,
    reducers: {
        setMod: (state, action: PayloadAction<boolean>) => {
        state.mod = action.payload;
        },
        setInvoices: (state, action: PayloadAction<Invoice[]>) => {
        state.invoices = action.payload;
        },
        setInvoiceId: (state, action: PayloadAction<string>) => {
        state.invoiceId = action.payload;
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchInvoice.fulfilled, (state, action) => {
                if (action.payload) {
                    state.invoice = action.payload;
                }
            })
            .addCase(fetchUserData.pending, (state) => {
                state.loadingUserData = true;
            })
            .addCase(fetchUserData.fulfilled, (state, action) => {
                state.loadingUserData = false;
                if (action.payload) {
                    state.userData = action.payload.userData;
                    state.invoices = action.payload.invoices;
                }
            })
            .addCase(fetchUserData.rejected, (state) => {
                state.loadingUserData = false;
            });
    },
});

// Export the actions generated by createSlice
export const { setMod, setInvoices, setInvoiceId } = userSlice.actions;

// Export the reducer
export default userSlice.reducer;
